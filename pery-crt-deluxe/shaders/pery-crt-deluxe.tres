[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
resource_local_to_scene = true
code = "/*
	This shader is based in:
	Libretro's crt-geom.glsl
	Source: https://github.com/libretro/glsl-shaders/blob/master/crt/shaders/crt-geom.glsl
	and
	
	
	This program is free software; you can redistribute it and/or modify it
	under the terms of the GNU General Public License as published by the Free
	Software Foundation; either version 2 of the License, or (at your option)
	any later version.
*/

shader_type canvas_item;
render_mode blend_mix;

// Curvature Toggle
uniform bool useCurvature = true;
// Curvature Distance
uniform float curvatureDistance: hint_range(0.1, 3.0, 0.1) = 1.6;
// Curvature Radius
uniform float curvatureRadius: hint_range(0.1, 10.0, 0.1) = 2.0;

// Corner Size
uniform float cornersize: hint_range(0.01, 1.0, 0.005) = 0.03;
// Corner Smoothness
uniform float cornersmooth: hint_range(50.0, 500.0, 10.0) = 100.0;


// Horizontal Tilt
uniform float x_tilt: hint_range(-0.5, 0.5, 0.05) = 0.0;
// Vertical Tilt
uniform float y_tilt: hint_range(-0.5, 0.5, 0.05) = 0.0;
// Horiz. Overscan %
uniform float overscan_x: hint_range(-125.0, 125.0, 1.0) = 100.0;
// Vert. Overscan %
uniform float overscan_y: hint_range(-125.0, 125.0, 1.0) = 100.0;






// hardScan
uniform float hardScan: hint_range(-20.0, 0.0, 1.0) = -8.0;

// hardPix
uniform float hardPix: hint_range(-20.0, 0.0, 1.0) = -3.0;

// warpX
uniform float warpX: hint_range(0.0, 0.125, 0.01) = 0.031;

// warpY
uniform float warpY: hint_range(0.0, 0.125, 0.01) = 0.041;

// maskDark
uniform float maskDark: hint_range(0.0, 2.0, 0.1) = 0.5;

// maskLight
uniform float maskLight: hint_range(0.0, 2.0, 0.1) = 1.5;

// scaleInLinearGamma
uniform float scaleInLinearGamma: hint_range(0.0, 1.0, 1.0) = 1.0;

// shadowMask
uniform float shadowMask: hint_range(0.0, 4.0, 1.0) = 3.0;

// brightness boost
uniform float brightBoost: hint_range(0.0, 2.0, 0.05) = 1.0;

// bloom-x soft
uniform float hardBloomPix: hint_range(-2.0, -0.5, 0.1) = -1.5;

// bloom-y soft
uniform float hardBloomScan: hint_range(-4.0, -1.0, 0.1) = -2.0;

// bloom ammount
uniform float bloomAmount: hint_range(0.0, 1.0, 0.05) = 0.15;

// filter kernel shape
uniform float shape: hint_range(0.0, 10.0, 0.05) = 2.0;








uniform vec2 OutputSize;
uniform vec2 TextureSize;
uniform vec2 InputSize;


uniform vec2 Offset;


varying vec2 overscan;
varying vec2 aspect;
varying vec3 stretch;
varying vec2 sinangle;
varying vec2 cosangle;
varying vec2 one;
varying float mod_factor;
varying vec2 ilfac;





varying vec2 convolution[4];




//Cuvature functions
float intersect(vec2 xy) {
	float d = curvatureDistance;
	float r = curvatureRadius;
	float A = dot(xy,xy)+d*d;
	float B = 2.0*(r*(dot(xy,sinangle)-d*cosangle.x*cosangle.y)-d*d);
	float C = d*d + 2.0*r*d*cosangle.x*cosangle.y;
	return (-B-sqrt(B*B-4.0*A*C))/(2.0*A);
}

vec2 bkwtrans(vec2 xy) {
	float R = curvatureRadius;
	float c = intersect(xy);
	vec2 point = vec2(c)*xy;
	point -= vec2(-R)*sinangle;
	point /= vec2(R);
	vec2 tang = sinangle/cosangle;
	vec2 poc = point/cosangle;
	float A = dot(tang,tang)+1.0;
	float B = -2.0*dot(poc,tang);
	float C = dot(poc,poc)-1.0;
	float a = (-B+sqrt(B*B-4.0*A*C))/(2.0*A);
	vec2 uv = (point-a*sinangle)/cosangle;
	float r = max(abs(R*acos(a) ), 1e-5); // FIX(R*acos(a))
	return uv*r/sin(r/R);
}

vec2 fwtrans(vec2 uv) {
	float r = max(abs( sqrt(dot(uv,uv)) ), 1e-5); // FIX(sqrt(dot(uv,uv)))
	float R = curvatureRadius;
	uv *= sin(r/R)/r;
	float x = 1.0-cos(r/R);
	float D = curvatureDistance/R + x*cosangle.x*cosangle.y+dot(uv,sinangle);
	return curvatureDistance*(uv*cosangle-x*sinangle)/D;
}

vec3 maxscale() {
	vec2 c = bkwtrans(-curvatureRadius * sinangle / (1.0 + curvatureRadius/curvatureDistance*cosangle.x*cosangle.y));
	vec2 a = vec2(0.5,0.5)*aspect;
	vec2 lo = vec2(fwtrans(vec2(-a.x,c.y)).x, fwtrans(vec2(c.x,-a.y)).y)/aspect;
	vec2 hi = vec2(fwtrans(vec2(+a.x,c.y)).x, fwtrans(vec2(c.x,+a.y)).y)/aspect;
	return vec3((hi+lo)*aspect*0.5,max(hi.x-lo.x,hi.y-lo.y));
}



void vertex() {

	overscan = vec2(1.00,1.00);

	aspect = vec2(1.0, 0.5625);
	
	const vec2 angle = vec2(0.0, 0.0);
	
	sinangle = sin(vec2(x_tilt, y_tilt)) + vec2(0.001);//sin(vec2(max(abs(x_tilt), 1e-3), max(abs(y_tilt), 1e-3)));
	cosangle = cos(vec2(x_tilt, y_tilt)) + vec2(0.001);//cos(vec2(max(abs(x_tilt), 1e-3), max(abs(y_tilt), 1e-3)));
	stretch = maxscale();
	
	ilfac = vec2(1.0,clamp(floor(InputSize.y/200.0), 1.0, 2.0));
	
	// The size of one texel, in texture-coordinates.
	vec2 sharpTextureSize = vec2(1.0 * TextureSize.x, TextureSize.y);
	one = ilfac / sharpTextureSize;
	
	// Resulting X pixel-coordinate of the pixel we're drawing.
	mod_factor = UV.x * TextureSize.x * OutputSize.x / InputSize.x;
	

	convolution[0] = UV + one * vec2(Offset.x+0.5,Offset.y+0.5) ;//top right
	convolution[1] = UV + one * vec2(-Offset.x-0.5,Offset.y-0.5) ;//bottom left
	convolution[2] = UV + one * vec2(-Offset.x-0.5,Offset.y+0.5) ;//top left
	convolution[3] = UV + one * vec2(Offset.x+0.5,-Offset.y-0.5) ;//bottom right
}


const float PI = 3.141592653589;


vec2 transform(vec2 coord) {
	coord *= TextureSize / InputSize;
	coord = (coord-vec2(0.5))*aspect*stretch.z+stretch.xy;
	return (bkwtrans(coord)/vec2(overscan_x / 100.0, overscan_y / 100.0)/aspect+vec2(0.5)) * InputSize / TextureSize;
}

float corner(vec2 coord) {
	coord *= TextureSize / InputSize;
	coord = (coord - vec2(0.5)) * vec2(overscan_x / 100.0, overscan_y / 100.0) + vec2(0.5);
	coord = min(coord, vec2(1.0)-coord) * aspect;
	vec2 cdist = vec2(cornersize);
	coord = (cdist - min(coord,cdist));
	float dist = sqrt(dot(coord,coord));
	return clamp((cdist.x-dist)*cornersmooth,0.0, 1.0);
}











float ToLinear1(float c) {
    if (scaleInLinearGamma == 0.) 
        return c;
    
    return(c<=0.04045) ? c/12.92 : pow((c + 0.055)/1.055, 2.4);
}

vec3 ToLinear(vec3 c) {
    if (scaleInLinearGamma==0.) 
        return c;
    
    return vec3(ToLinear1(c.r), ToLinear1(c.g), ToLinear1(c.b));
}

// Linear to sRGB.
// Assuming using sRGB typed textures this should not be needed.
float ToSrgb1(float c) {
    if (scaleInLinearGamma == 0.) 
        return c;
    
    return(c<0.0031308 ? c*12.92 : 1.055*pow(c, 0.41666) - 0.055);
}

vec3 ToSrgb(vec3 c) {
    if (scaleInLinearGamma == 0.) 
        return c;
    
    return vec3(ToSrgb1(c.r), ToSrgb1(c.g), ToSrgb1(c.b));
}

//#endif

// Nearest emulated sample given floating point position and texel offset.
// Also zero's off screen.
vec3 Fetch(sampler2D _TEXTURE, vec2 pos,vec2 off) {
	//pos=(floor(pos*SourceSize.xy+off)+vec2(0.5,0.5))/SourceSize.xy;
	pos=(floor(pos*vec4(TextureSize, 1.0 / TextureSize).xy+off)+vec2(0.5,0.5))/vec4(TextureSize, 1.0 / TextureSize).xy;
	
	//#ifdef SIMPLE_LINEAR_GAMMA
	//return ToLinear(brightBoost * pow(texture(_TEXTURE,pos.xy).rgb, vec3(2.2)));
	//#else
	return ToLinear(brightBoost * texture(_TEXTURE,pos.xy).rgb);
	//#endif
}

// Distance in emulated pixels to nearest texel.
vec2 Dist(vec2 pos) {
	//pos = pos*SourceSize.xy;
	pos = pos*vec4(TextureSize, 1.0 / TextureSize).xy;
	
	return -((pos - floor(pos)) - vec2(0.5));
}

// 1D Gaussian.
float Gaus(float pos, float scale) {
	return exp2(scale*pow(abs(pos), shape));
}

// 3-tap Gaussian filter along horz line.
vec3 Horz3(sampler2D _TEXTURE, vec2 pos, float off) {
	vec3 b    = Fetch(_TEXTURE, pos, vec2(-1.0, off));
	vec3 c    = Fetch(_TEXTURE, pos, vec2( 0.0, off));
	vec3 d    = Fetch(_TEXTURE, pos, vec2( 1.0, off));
	float dst = Dist(pos).x;
	
	// Convert distance to weight.
	float scale = hardPix;
	float wb = Gaus(dst-1.0,scale);
	float wc = Gaus(dst+0.0,scale);
	float wd = Gaus(dst+1.0,scale);
	
	// Return filtered sample.
	return (b*wb+c*wc+d*wd)/(wb+wc+wd);
}

// 5-tap Gaussian filter along horz line.
vec3 Horz5(sampler2D _TEXTURE, vec2 pos,float off) {
	vec3 a = Fetch(_TEXTURE, pos,vec2(-2.0, off));
	vec3 b = Fetch(_TEXTURE, pos,vec2(-1.0, off));
	vec3 c = Fetch(_TEXTURE, pos,vec2( 0.0, off));
	vec3 d = Fetch(_TEXTURE, pos,vec2( 1.0, off));
	vec3 e = Fetch(_TEXTURE, pos,vec2( 2.0, off));
	
	float dst = Dist(pos).x;
	// Convert distance to weight.
	float scale = hardPix;
	float wa = Gaus(dst - 2.0, scale);
	float wb = Gaus(dst - 1.0, scale);
	float wc = Gaus(dst + 0.0, scale);
	float wd = Gaus(dst + 1.0, scale);
	float we = Gaus(dst + 2.0, scale);
	
	// Return filtered sample.
	return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);
}

// 7-tap Gaussian filter along horz line.
vec3 Horz7(sampler2D _TEXTURE, vec2 pos,float off) {
	vec3 a = Fetch(_TEXTURE, pos, vec2(-3.0, off));
	vec3 b = Fetch(_TEXTURE, pos, vec2(-2.0, off));
	vec3 c = Fetch(_TEXTURE, pos, vec2(-1.0, off));
	vec3 d = Fetch(_TEXTURE, pos, vec2( 0.0, off));
	vec3 e = Fetch(_TEXTURE, pos, vec2( 1.0, off));
	vec3 f = Fetch(_TEXTURE, pos, vec2( 2.0, off));
	vec3 g = Fetch(_TEXTURE, pos, vec2( 3.0, off));
	
	float dst = Dist(pos).x;
	// Convert distance to weight.
	float scale = hardBloomPix;
	float wa = Gaus(dst - 3.0, scale);
	float wb = Gaus(dst - 2.0, scale);
	float wc = Gaus(dst - 1.0, scale);
	float wd = Gaus(dst + 0.0, scale);
	float we = Gaus(dst + 1.0, scale);
	float wf = Gaus(dst + 2.0, scale);
	float wg = Gaus(dst + 3.0, scale);
	
	// Return filtered sample.
return (a*wa+b*wb+c*wc+d*wd+e*we+f*wf+g*wg)/(wa+wb+wc+wd+we+wf+wg);
}

// Return scanline weight.
float Scan(vec2 pos, float off) {
	float dst = Dist(pos).y;
	
	return Gaus(dst + off, hardScan);
}
  
// Return scanline weight for bloom.
float BloomScan(vec2 pos, float off) {
	float dst = Dist(pos).y;
	
	return Gaus(dst + off, hardBloomScan);
}

// Allow nearest three lines to effect pixel.
vec3 Tri(sampler2D _TEXTURE, vec2 pos) {
	vec3 a = Horz3(_TEXTURE, pos,-1.0);
	vec3 b = Horz5(_TEXTURE, pos, 0.0);
	vec3 c = Horz3(_TEXTURE, pos, 1.0);
	
	float wa = Scan(pos,-1.0); 
	float wb = Scan(pos, 0.0);
	float wc = Scan(pos, 1.0);
	
	return a*wa + b*wb + c*wc;
}
  
// Small bloom.
vec3 Bloom(sampler2D _TEXTURE, vec2 pos) {
	vec3 a = Horz5(_TEXTURE, pos,-2.0);
	vec3 b = Horz7(_TEXTURE, pos,-1.0);
	vec3 c = Horz7(_TEXTURE, pos, 0.0);
	vec3 d = Horz7(_TEXTURE, pos, 1.0);
	vec3 e = Horz5(_TEXTURE, pos, 2.0);
	
	float wa = BloomScan(pos,-2.0);
	float wb = BloomScan(pos,-1.0); 
	float wc = BloomScan(pos, 0.0);
	float wd = BloomScan(pos, 1.0);
	float we = BloomScan(pos, 2.0);
	
	return a*wa+b*wb+c*wc+d*wd+e*we;
}

// Shadow mask.
vec3 Mask(vec2 pos) {
	vec3 mask = vec3(maskDark, maskDark, maskDark);
	
	// Very compressed TV style shadow mask.
	if (shadowMask == 1.0) 
	{
	    float line = maskLight;
	    float odd = 0.0;
	    
	    if (fract(pos.x*0.166666666) < 0.5) odd = 1.0;
	    if (fract((pos.y + odd) * 0.5) < 0.5) line = maskDark;  
	    
	    pos.x = fract(pos.x*0.333333333);
	
	    if      (pos.x < 0.333) mask.r = maskLight;
	    else if (pos.x < 0.666) mask.g = maskLight;
	    else                    mask.b = maskLight;
	    mask*=line;  
	} 
	
	// Aperture-grille.
	else if (shadowMask == 2.0) 
	{
	    pos.x = fract(pos.x*0.333333333);
	
	    if      (pos.x < 0.333) mask.r = maskLight;
	    else if (pos.x < 0.666) mask.g = maskLight;
	    else                    mask.b = maskLight;
	} 
	
	// Stretched VGA style shadow mask (same as prior shaders).
	else if (shadowMask == 3.0) 
	{
	    pos.x += pos.y*3.0;
	    pos.x  = fract(pos.x*0.166666666);
	
	    if      (pos.x < 0.333) mask.r = maskLight;
	    else if (pos.x < 0.666) mask.g = maskLight;
	    else                    mask.b = maskLight;
	}
	
	// VGA style shadow mask.
	else if (shadowMask == 4.0) 
	{
	    pos.xy  = floor(pos.xy*vec2(1.0, 0.5));
	    pos.x  += pos.y*3.0;
	    pos.x   = fract(pos.x*0.166666666);
	
	    if      (pos.x < 0.333) mask.r = maskLight;
	    else if (pos.x < 0.666) mask.g = maskLight;
	    else                    mask.b = maskLight;
	}
	
	return mask;
}




void fragment() {

	vec2 xy = useCurvature ? transform(UV.xy) : UV.xy;
	float cval = useCurvature ? corner(xy) : 1.0;
	
	
	vec3 outColor = Tri(TEXTURE, xy);
	vec3 bloom = Bloom(TEXTURE, xy);
	outColor.rgb += bloom * bloomAmount;
	
	if (shadowMask > 0.0)
	    outColor.rgb *= Mask(FRAGCOORD.xy * 1.000001);
	
	vec4 border = vec4(0.0,0.0,0.0,1.0);
	COLOR = mix (border , vec4(ToSrgb(outColor.rgb), 1.0), cval);
} 
"

[resource]
resource_local_to_scene = true
shader = SubResource( 1 )
shader_param/useCurvature = true
shader_param/curvatureDistance = 3.0
shader_param/curvatureRadius = 2.0
shader_param/cornersize = 0.03
shader_param/cornersmooth = 100.0
shader_param/x_tilt = -0.2
shader_param/y_tilt = 0.0
shader_param/overscan_x = 100.0
shader_param/overscan_y = 100.0
shader_param/hardScan = -20.0
shader_param/hardPix = -20.0
shader_param/warpX = 0.031
shader_param/warpY = 0.041
shader_param/maskDark = 1.2
shader_param/maskLight = 0.5
shader_param/scaleInLinearGamma = 1.0
shader_param/shadowMask = 1.0
shader_param/brightBoost = 1.0
shader_param/hardBloomPix = -0.5
shader_param/hardBloomScan = -4.0
shader_param/bloomAmount = 0.15
shader_param/shape = 2.2
shader_param/OutputSize = Vector2( 1152, 648 )
shader_param/TextureSize = Vector2( 384, 216 )
shader_param/InputSize = Vector2( 384, 216 )
shader_param/Offset = Vector2( 0.221, 1.612 )
